---
phase: 02-statistical-analysis-domain-insights
plan: 03
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/pareto.py
  - scripts/09_pareto_frontier.py
  - data/processed/pareto_frontier.parquet
  - reports/figures/pareto_frontier_intelligence_price.png
  - reports/figures/pareto_frontier_speed_intelligence.png
  - reports/pareto_analysis_2026-01-18.md
autonomous: true

must_haves:
  truths:
    - "Pareto-efficient models identified in price-performance space"
    - "Frontier analysis reveals optimal models balancing competing objectives"
    - "Multiple objectives analyzed (Intelligence-Price, Speed-Intelligence)"
    - "Value propositions and market leaders identified"
  artifacts:
    - path: "src/pareto.py"
      provides: "Pareto frontier analysis utilities"
      exports: ["compute_pareto_frontier", "plot_pareto_frontier"]
      min_lines: 150
    - path: "scripts/09_pareto_frontier.py"
      provides: "Pareto frontier analysis pipeline"
      min_lines: 100
    - path: "data/processed/pareto_frontier.parquet"
      provides: "Dataset with Pareto efficiency flags"
      contains: "is_pareto_efficient column"
    - path: "reports/figures/pareto_frontier_intelligence_price.png"
      provides: "Price-performance frontier visualization"
    - path: "reports/pareto_analysis_2026-01-18.md"
      provides: "Narrative report of Pareto analysis findings"
  key_links:
    - from: "scripts/09_pareto_frontier.py"
      to: "data/processed/ai_models_deduped.parquet"
      via: "Input deduplicated dataset"
      pattern: "ai_models_deduped"
    - from: "src/pareto.py"
      to: "numpy"
      via: "Vectorized Pareto dominance computation"
      pattern: "np\\.(hstack|any|all)"
    - from: "data/processed/pareto_frontier.parquet"
      to: "scripts/10_statistical_tests.py"
      via: "Pareto flags for group comparisons"
      pattern: "is_pareto_efficient"
---

<objective>
Identify Pareto-efficient models that dominate in multi-objective optimization space (Intelligence vs Price, Speed vs Intelligence) to reveal value propositions and market leaders.

Purpose: Discover which models offer optimal tradeoffs between competing objectives (e.g., high intelligence at low price, high speed with high intelligence). Pareto frontier analysis identifies models that are not dominated by any other model (no other model is better in all objectives).

Output: Pareto-efficient model flags, frontier visualizations, and narrative report identifying market leaders and value propositions (STAT-02).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-statistical-analysis-domain-insights/02-RESEARCH.md

@data/processed/ai_models_deduped.parquet
@src/analyze.py
@.planning/phases/02-statistical-analysis-domain-insights/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Pareto frontier utilities</name>
  <files>src/pareto.py</files>
  <action>
Create src/pareto.py with script-as-module pattern:

**Functions to implement:**

1. `compute_pareto_frontier(df: pl.DataFrame, maximize: list[str], minimize: list[str]) -> pl.DataFrame`
   - Implement Pareto dominance algorithm from RESEARCH.md
   - For maximization: higher is better (e.g., intelligence_index)
   - For minimization: lower is better (e.g., price_usd)
   - Convert minimization to maximization by negating: obj_min = -df.select(minimize).to_numpy()
   - Combine objectives: all_objectives = np.hstack([obj_max, obj_min])
   - Check dominance: model j dominates i if (all_objectives[j] >= all_objectives[i]) AND (any(all_objectives[j] > all_objectives[i]))
   - Return DataFrame with is_pareto_efficient boolean column
   - Add pareto_rank column (1 = efficient, 2+ = dominated by 1 efficient model, etc.)

2. `get_pareto_efficient_models(df: pl.DataFrame) -> pl.DataFrame`
   - Filter df.filter(pl.col("is_pareto_efficient"))
   - Sort by relevant objectives
   - Return subset with only efficient models

3. `compute_hypervolume(df: pl.DataFrame, maximize: list[str], minimize: list[str], reference_point: dict) -> float`
   - Calculate hypervolume indicator (area dominated by Pareto frontier)
   - Uses reference_point as worst-case scenario
   - Returns scalar measure of frontier quality
   - Optional: Use for comparing different Pareto frontiers

4. `plot_pareto_frontier(df: pl.DataFrame, x_col: str, y_col: str, x_minimize: bool, y_maximize: bool, output_path: str, title: str) -> None`
   - Create Pareto frontier scatter plot
   - Plot dominated models in gray/alpha
   - Plot Pareto-efficient models in red with larger markers
   - Annotate Pareto-efficient models with model names
   - Add axis labels, title, legend, grid
   - Use matplotlib with seaborn style
   - Save as high-resolution PNG (300 DPI)

**Dependencies:**
- Import numpy as np
- Import polars as pl
- Import matplotlib.pyplot as plt
- Use pattern from src/analyze.py for plotting

**Key algorithm (from RESEARCH.md Pattern 5):**
```python
# For each model i, check if any model j dominates it
n = len(df)
is_pareto = np.ones(n, dtype=bool)

for i in range(n):
    for j in range(n):
        if i != j:
            # j dominates i if j is better or equal in all objectives
            # and strictly better in at least one
            if np.all(all_objectives[j] >= all_objectives[i]) and \
               np.any(all_objectives[j] > all_objectives[i]):
                is_pareto[i] = False
                break
```
  </action>
  <verify>
```bash
# Test Pareto functions
python3 -c "
import sys
sys.path.insert(0, '.')
from src.pareto import compute_pareto_frontier, get_pareto_efficient_models
import polars as pl

# Create test data
test_df = pl.DataFrame({
    'model': ['A', 'B', 'C', 'D'],
    'intelligence': [80, 90, 85, 70],
    'price': [10, 15, 8, 5]
})

# Compute Pareto frontier (maximize intelligence, minimize price)
result = compute_pareto_frontier(test_df, maximize=['intelligence'], minimize=['price'])
print(result)
print(f'Pareto efficient: {result.filter(pl.col(\"is_pareto_efficient\"))[\"model\"].to_list()}')

# Verify: B dominates A (better intelligence, higher price is OK), C dominates A (lower price, slightly lower intelligence)
# Expected Pareto: B, C (maybe D depending on exact values)
"
```
  </verify>
  <done>
- compute_pareto_frontier() correctly identifies dominated models
- is_pareto_efficient column added to DataFrame
- get_pareto_efficient_models() returns only efficient models
- Algorithm handles multiple objectives (maximize + minimize)
- Functions handle null values appropriately
  </done>
</task>

<task type="auto">
  <name>Task 2: Execute Pareto frontier analysis pipeline</name>
  <files>scripts/09_pareto_frontier.py</files>
  <action>
Create scripts/09_pareto_frontier.py as executable script:

**Script structure:**
```python
#!/usr/bin/env python3
"""
Pareto Frontier Analysis Pipeline - Phase 2 Plan 03

Identifies Pareto-efficient models that dominate in multi-objective space.
Analyzes price-performance and speed-intelligence tradeoffs.

Usage:
    PYTHONPATH=. python3 scripts/09_pareto_frontier.py
"""

import polars as pl
import numpy as np
from src.pareto import compute_pareto_frontier, get_pareto_efficient_models, plot_pareto_frontier
from pathlib import Path
from datetime import datetime

def main():
    # Load deduplicated dataset
    input_path = "data/processed/ai_models_deduped.parquet"
    output_path = "data/processed/pareto_frontier.parquet"
    report_path = "reports/pareto_analysis_2026-01-18.md"

    print(f"Loading: {input_path}")
    df = pl.read_parquet(input_path)
    print(f"Loaded {df.height} models")

    # Filter to models with valid intelligence scores
    df_valid = df.filter(pl.col("Intelligence Index").is_not_null())
    print(f"Models with valid intelligence: {df_valid.height}")

    # Analysis 1: Intelligence vs Price (maximize intelligence, minimize price)
    print("\n=== PARETO FRONTIER 1: INTELLIGENCE VS PRICE ===")
    df_pareto1 = compute_pareto_frontier(
        df_valid,
        maximize=["Intelligence Index"],
        minimize=["price_usd"]
    )
    efficient1 = df_pareto1.filter(pl.col("is_pareto_efficient"))
    print(f"Pareto-efficient models: {len(efficient1)}/{len(df_pareto1)}")

    # Plot Intelligence vs Price frontier
    plot_pareto_frontier(
        df_pareto1,
        x_col="price_usd",
        y_col="Intelligence Index",
        x_minimize=True,
        y_maximize=True,
        output_path="reports/figures/pareto_frontier_intelligence_price.png",
        title="Price-Performance Pareto Frontier (Intelligence vs Price)"
    )

    # Analysis 2: Speed vs Intelligence (maximize both)
    print("\n=== PARETO FRONTIER 2: SPEED VS INTELLIGENCE ===")
    df_pareto2 = compute_pareto_frontier(
        df_valid,
        maximize=["Speed(median token/s)", "Intelligence Index"],
        minimize=[]
    )
    efficient2 = df_pareto2.filter(pl.col("is_pareto_efficient"))
    print(f"Pareto-efficient models: {len(efficient2)}/{len(df_pareto2)}")

    # Plot Speed vs Intelligence frontier
    plot_pareto_frontier(
        df_pareto2,
        x_col="Speed(median token/s)",
        y_col="Intelligence Index",
        x_minimize=False,
        y_maximize=True,
        output_path="reports/figures/pareto_frontier_speed_intelligence.png",
        title="Speed-Intelligence Pareto Frontier"
    )

    # Analysis 3: Multi-objective (Intelligence, Speed, Price, Latency)
    print("\n=== PARETO FRONTIER 3: MULTI-OBJECTIVE ===")
    df_pareto3 = compute_pareto_frontier(
        df_valid,
        maximize=["Intelligence Index", "Speed(median token/s)"],
        minimize=["price_usd", "Latency (First Answer Chunk /s)"]
    )
    efficient3 = df_pareto3.filter(pl.col("is_pareto_efficient"))
    print(f"Pareto-efficient models: {len(efficient3)}/{len(df_pareto3)}")

    # Merge Pareto flags into main dataset
    df_final = df.with_columns([
        pl.Series("is_pareto_intelligence_price", df_pareto1["is_pareto_efficient"]),
        pl.Series("is_pareto_speed_intelligence", df_pareto2["is_pareto_efficient"]),
        pl.Series("is_pareto_multi_objective", df_pareto3["is_pareto_efficient"])
    ])

    # Save results
    print(f"\nSaving: {output_path}")
    df_final.write_parquet(output_path)

    # Generate Pareto analysis report
    generate_pareto_report(
        df_final,
        efficient1,
        efficient2,
        efficient3,
        report_path
    )
    print(f"Report: {report_path}")

    print("\nâœ“ Pareto frontier analysis complete")

def generate_pareto_report(df, efficient1, efficient2, efficient3, output_path):
    """Generate narrative report of Pareto frontier findings."""
    # Implement report generation with:
    # - Summary of each Pareto frontier analysis
    # - List of Pareto-efficient models for each objective
    # - Market leaders identification
    # - Value propositions (best bang for buck)
    # - Frontier interpretation
    # Follow pattern from scripts/05_quality_report.py

    # ... implementation ...

if __name__ == "__main__":
    main()
```

**Implement generate_pareto_report():**
- Section 1: Intelligence vs Price Frontier (value leaders)
- Section 2: Speed vs Intelligence Frontier (performance leaders)
- Section 3: Multi-Objective Frontier (overall optimal models)
- Tables of Pareto-efficient models with key metrics
- Interpretation: What makes these models optimal?
- Market insights: Which providers dominate the frontier?
- Recommendations: Model selection guidance

**Follow pattern from:** scripts/08_correlation_analysis.py (pipeline structure), scripts/05_quality_report.py (report generation)
  </action>
  <verify>
```bash
# Execute script
PYTHONPATH=. python3 scripts/09_pareto_frontier.py

# Verify output files
ls -lh data/processed/pareto_frontier.parquet
ls -lh reports/figures/pareto_frontier_*.png
ls -lh reports/pareto_analysis_2026-01-18.md

# Verify Pareto results
python3 -c "
import polars as pl
df = pl.read_parquet('data/processed/pareto_frontier.parquet')
print(f'Total models: {df.height}')
print(f'Pareto columns: {[c for c in df.columns if \"pareto\" in c]}')
for col in [c for c in df.columns if 'is_pareto' in c]:
    count = df.filter(pl.col(col) == True).height
    print(f'{col}: {count} models')
"
```
  </verify>
  <done>
- Script executes without errors
- Three Pareto frontier analyses completed (Intelligence-Price, Speed-Intelligence, Multi-Objective)
- Pareto-efficient models identified for each frontier
- Frontier visualizations generated with annotations
- Report generated with market insights and recommendations
- Dataset saved with Pareto flags
  </done>
</task>

</tasks>

<verification>
## Overall Verification Steps

1. **Pareto Algorithm Verification:**
   - Dominance logic correct (all objectives better or equal, at least one strictly better)
   - Maximization and minimization handled correctly
   - No false positives (dominated models incorrectly marked as efficient)

2. **Frontier Analysis Verification:**
   - Intelligence vs Price: Identifies value leaders (high intelligence, low price)
   - Speed vs Intelligence: Identifies performance leaders (high speed, high intelligence)
   - Multi-objective: Identifies overall optimal models

3. **Visualization Verification:**
   - Dominated models shown in gray with transparency
   - Pareto-efficient models highlighted in red with larger markers
   - Efficient models annotated with model names
   - Clear axis labels and titles
   - High resolution (300 DPI)

4. **Dataset Verification:**
   - Original dataset preserved (188 models)
   - Pareto flag columns added (is_pareto_intelligence_price, etc.)
   - No data loss or corruption

5. **Documentation Verification:**
   - Pareto-efficient models listed for each frontier
   - Market leaders identified
   - Value propositions explained
   - Recommendations provided

6. **Reproducibility Verification:**
   - All code documented
   - Functions importable by notebook
   - Algorithm well-documented
</verification>

<success_criteria>
- [ ] Pareto frontier algorithm implemented correctly
- [ ] Three frontier analyses completed (Intelligence-Price, Speed-Intelligence, Multi-Objective)
- [ ] Pareto-efficient models identified for each analysis
- [ ] Frontier visualizations generated with annotations
- [ ] Narrative report with market insights
- [ ] Dataset saved with Pareto flags
- [ ] Value propositions identified
- [ ] Market leaders highlighted
- [ ] Functions importable by notebook
- [ ] Dependencies on Plan 02-01 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-statistical-analysis-domain-insights/02-03-SUMMARY.md` with:
- Pareto frontier summary (how many efficient models per analysis)
- Key Pareto-efficient models identified
- Market insights and value propositions
- Frontiers generated
- Dependencies on Plan 02-01
</output>
